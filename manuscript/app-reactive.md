# Application implemented using Reactive Programming
## Introduction

Initially the book was thought to explain all the concepts in a single section but we figured out that can be overwhelming for developers giving their first steps in Reactive Programming. In this new version we'll introduce the conceps using an example app with the basic elements of any iOS app:

- Interaction with databases and API REST.
- Business logic applied to the received data.
- Login and session persistence. 
- User interaction with the app.

The example app is a [GitHub](https://github.com) client for iOS with a navigation based on a tabbar with 3 main views:

- **Repositories**: This view will present all the user repositories in a table view. 
- **Notifications**: For listing all your unread notifications on GitHub, allowing the user to mark them as read and unsubscribe from these threads.
- **Accounts**: Presenting the user account with a logout option.

Apart from these 3 main views in tht `TabbarController` the application will also have a couple of extra views, one for listing the issues inside a given repository, and the other one for presenting the issue information in a modal view.

All of the views above need core components to interact with data sources:

| Data Source            | Interaction                                                                                                                                                                                        |
|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP Rest API          | Retrieving data from the user account on SoundCloud. In some views like Search we will present the data without any previous persistence but in some others, the data will be persisted.           |
| Realm (Local Database) | Fetching and saving data from the user profile like favourites or playlists. Thanks to local persistence the user can navigate through the app and have content pre-loaded.                        |
| Keychain               | Storing the user session needed in every request sent to the API. The session is persisted once the user logs in, and cleaned when the user logouts. The session is persisted across app launches. |


### Notes

- The app is implemented using [RxSwift](https://github.com/reactivex/rxswift) but it is also explained how the features could be implemented using [ReactiveCocoa](https://github.com/reactivecocoa/reactivecocoa) in case you decide using ReactiveCocoa instead of RxSwift.


# CHANGE THE API URL
- The API reference is available [here](https://developers.soundcloud.com/docs/api/reference). Only the required endpoints are implemented in the API client but you can extend the same building logic to add new endpoints or models.
- External dependencies of the project are resolved using [CocoaPods](https://cocoapods.org) but all of them offer support for [Carthage](https://github.com/carthage/carthage) as well.
- The architecture followed by the app is **VIPER** where views are pure passive components. Presenters are responsible of briging the data and formatting it to be presented. The data us fetched using interactors that applythe business logic to the data that is fetched from repositories.
where views will behaves as passive components, and the presenters will format the data for its presentation.
- Layouts are built by code using [SnapKit](https://github.com/SnapKit/SnapKit) to simplify autolayouts.

If you haven't setup the project yet, do it! It's easier going through the book having a look to the project in Xcode. Remember that the project is available on this repository.

## Commands Pattern 

Our application business logic will be encapsulated in atomic operations with a single purpose. These operations will be modelled as commands that will be initialized with the required data in order to execute such operation. These commands will be generated by factories that will be responsible to set them up. Our commands will be `NSOperations` under the hood, but whose execution will be controlled using a reactive interface. Let's start coding our *Command Pattern components*.

Our commands will be a **generic** version of `NSOperation` with two types, the returned data type, and the error type *(since our commands can also fail)*. The command structure would be like:

```swift
class Command<T, E>: NSOperation {
    
    override func main() {
        // Command operation
    }
    
}
```

Remembering how `NSOperation` works, when it's added to an `NSOperationQueue` when it's about to be executed, `NSOperationQueue` executes the `main()` method in our command. That method doesn't return any information about the completion, either value, or error, and in our case we're interested in these values since we might need them to combine the data with other operations values using Reactive. To get that information back from the execution we're going to extend the `Command` adding an extra method, `execute()` which will return a `Result` type.

> `Result` is a type, provided by [this library]() with the same name, that encapsulate in the same type both, a


## Core Components

### Keychain

The first component we're going to implement using Reactive is going to be the accessor to the Keychain in order to persist the user session.

